.. _raster.arcinfo_grid_format:

================================================================================
Arc/Info Binary Grid Format
================================================================================

*작성자* `프랑크 바르메르담(Frank Warmerdam) <http://pobox.com/~warmerdam>`_
(warmerdam@pobox.com)

Arc/Info 바이너리 그리드 포맷은 Arc/Info 그리드 상품의 내부 작업 포맷입니다. ArcView의 공간 분석 구성요소 내에서도 사용 및 생성할 수 있습니다. 이 포맷은 4바이트 정수형 또는 4바이트 부동소수점형까지의 래스터 데이터를 담을 수 있는 런 렝스 부호화(run-length encoding) 압축 알고리즘을 가진 타일화(블록화) 포맷입니다.

그리드 용 교환 포맷인 Arc/Info 아스키 그리드 포맷과 이 포맷을 혼동해서는 안 됩니다. Arc/Info에서 GRIDASCII 및 ASCIIGRID 명령어를 사용하면 파일을 바이너리와 아스키 포맷 간에 서로 변환할 수 있습니다. 이 포맷은 GRIDFLOAT 명령어가 산출하는 플랫 바이너리(flat binary) 래스터와도 다릅니다. ArcView 내에서 Arc/Info 바이너리 부동소수점형 포맷과 아스키 포맷에도 접근할 수 있습니다.

ESRI BIL 포맷으로 알려진 포맷도 이 포맷과 혼동해서는 안 됩니다. ESRI BIL 포맷이란 실제로는 래스터 데이터를 담고 있는 바이너리 래스터 파일의 데이터 레이아웃을 설명하는 헤더 파일(.HDR)을 생성하는 표준 ESRI 방식을 말합니다.

버전
-------

그리드 파일의 버전이 작동하는 방식은 확실하지 않습니다. 저자는 ArcView 3.x버전이 생성한 그리드 파일과 관련 그리드 I/O API를 주로 작업해왔습니다. 저자가 살펴봤던 hdr.adf 파일들은 무슨 뜻인지는 모르겠지만 **GRID1.2** 이라는 문자열로 시작합니다. 파일 명명 규범은 확실히 Arc/Info 7.x 이전 버전보다는 이후 버전의 규범을 따르는 것으로 보입니다.

파일셋
--------

실제로 그리드 커버리지는 파일 여러 개로 구성되어 있습니다. 그리드는 일반적으로 해당 그리드의 이름을 딴 자신만의 디렉터리 안에 존재합니다. 예를 들어 **nwgrd1** 그리드는 **nwgrd1** 디렉터리 안에 있으며, 다음과 같은 구성요소 파일을 가지고 있습니다:

::

   -rwxr--r--   1 warmerda users          32 Jan 22 16:07 nwgrd1/dblbnd.adf
   -rwxr--r--   1 warmerda users         308 Jan 22 16:07 nwgrd1/hdr.adf
   -rwxr--r--   1 warmerda users          32 Jan 22 16:07 nwgrd1/sta.adf
   -rwxr--r--   1 warmerda users        2048 Jan 22 16:07 nwgrd1/vat.adf
   -rwxr--r--   1 warmerda users      187228 Jan 22 16:07 nwgrd1/w001001.adf
   -rwxr--r--   1 warmerda users        6132 Jan 22 16:07 nwgrd1/w001001x.adf

그리드 데이터셋이 일반 ESRI 서식으로 된 투영법 정의를 담고 있는 prj.adf 파일도 포함하는 경우가 있습니다. 또 일반적으로 info 디렉터리에 관련 테이블도 가지고 있습니다. 이는 저자가 현재 이 문서에서 논하고자 하는 범위를 넘어섭니다.

이 파일들은 다음과 같은 역할을 합니다:

-  `dblbnd.adf <#dblbnd>`_: 사용 중인 그리드의 일부분의 경계(LLX, LLY, URX, URY)를 담고 있습니다.
-  `hdr.adf <#hdr.adf>`_: 이 파일은 헤더로, 데이터셋에 있는 타일의 크기 및 개수에 대한 정보를 담고 있습니다. 필자가 아직까지 파악하지 못 한 여러 가지 다른 정보도 담고 있습니다.
-  `sta.adf <#sta>`_: 래스터 통계를 담고 있습니다. 특히 래스터 최소값, 최대값, 평균 및 표준 편차를 반드시 담고 있습니다.
-  **vat.adf**: 속성 테이블의 값과 관련된 파일입니다. 이 파일은 일련의 속성들을 가진 정수형 래스터 값에 대응하는 테이블입니다. 벡터 커버리지의 pat.adf 파일과 비슷한 방식으로 정보를 가리키는 포인터일 뿐이라고 생각되지만, 아직 연구해보지는 못 했습니다.
-  `w001001.adf <#w001001>`_: 이 파일이 실제 래스터 데이터를 담고 있습니다.
-  `w001001x.adf <#w001001x>`_: w001001.adf 래스터 파일에 있는 각 타일을 가리키는 포인터들을 담고 있는 색인 파일입니다.

--------------

dblbnd.adf - 지리참조 경계(Georef Bounds)
----------------------------------------

.. list-table:: Georef Bounds
   :header-rows: 1

   * - 필드명
     - 시작 바이트
     - 바이트 개수
     - 포맷
     - 설명
   * - D_LLX
     - 0
     - 8
     - MSB double
     - 그리드의 좌하단 X(편동). 지리참조되지 않은 그리드의 경우 일반적으로 0.5를 뺍니다.
   * - D_LLY
     - 8
     - 8
     - MSB double
     - 그리드의 좌하단 Y(편북). 지리참조되지 않은 그리드의 경우 일반적으로 0.5를 뺍니다.
   * - D_URX
     - 16
     - 8
     - MSB double
     - 그리드의 우상단 X(편동). 지리참조되지 않은 그리드의 경우 일반적으로 픽셀 개수에서 0.5를 뺍니다.
   * - D_URY
     - 24
     - 8
     - MSB double
     - 그리드의 우상단 Y(편북). 지리참조되지 않은 그리드의 경우 일반적으로 픽셀 개수에서 0.5를 뺍니다.

이 파일의 용량은 항상 32바이트입니다. 이 경계는 그리드 전체가 아니라 사용 중인 그리드의 일부분에 적용됩니다.

--------------

w001001x.adf - 타일 색인
-------------------------

다음은 w001001x.adf 파일의 처음 320바이트를 바이너리 덤프한 것입니다.

::

          0: 0000270A FFFFFC14 00000000 00000000 ~~'~~~~~~~~~~~~~
         16: 00000000 00000000 00000BFA 00000000 ~~~~~~~~~~~~~~~~
         32: 00000000 00000000 00000000 00000000 ~~~~~~~~~~~~~~~~
         48: 00000000 00000000 00000000 00000000 ~~~~~~~~~~~~~~~~
         64: 00000000 00000000 00000000 00000000 ~~~~~~~~~~~~~~~~
         80: 00000000 00000000 00000000 00000000 ~~~~~~~~~~~~~~~~
         96: 00000000 00000032 00000202 00000235 ~~~~~~~2~~~~~~~5
        112: 000001D4 0000040A 00000000 0000040B ~~~~~~~~~~~~~~~~
        128: 00000000 0000040C 00000000 0000040D ~~~~~~~~~~~~~~~~
        144: 00000000 0000040E 00000000 0000040F ~~~~~~~~~~~~~~~~
        160: 00000000 00000410 00000202 00000613 ~~~~~~~~~~~~~~~~
        176: 000001D4 000007E8 00000000 000007E9 ~~~~~~~~~~~~~~~~
        192: 00000000 000007EA 00000000 000007EB ~~~~~~~~~~~~~~~~
        208: 00000000 000007EC 00000000 000007ED ~~~~~~~~~~~~~~~~
        224: 00000000 000007EE 00000202 000009F1 ~~~~~~~~~~~~~~~~
        240: 000001D4 00000BC6 00000000 00000BC7 ~~~~~~~~~~~~~~~~
        256: 00000000 00000BC8 00000000 00000BC9 ~~~~~~~~~~~~~~~~
        272: 00000000 00000BCA 00000000 00000BCB ~~~~~~~~~~~~~~~~
        288: 00000000 00000BCC 00000202 00000DCF ~~~~~~~~~~~~~~~~
        304: 000001D4 00000FA4 00000000 00000FA5 ~~~~~~~~~~~~~~~~

.. list-table:: Tile Index
   :header-rows: 1

   * - 필드
     - 시작 바이트
     - 바이트 개수
     - 포맷
     - 설명
   * - 
     - 0
     - 8
     - Magic Number
     - 언제나 16진법 00 00 27 0A FF FF \** \**로, 일반적으로 FC 14, FB F8 또는 FC 08로 끝납니다.
   * - 
     - 8
     - 16
     - zero fill
     - 
   * - 
     - 24
     - 4
     - MSB Int32
     - 전체 파일의 Short 유형 단위 용량(2를 곱하면 바이트 단위 파일 용량이 됩니다)
   * - 
     - 28
     - 72
     - zero fill
     - 
   * - 
     - 100 + **t**\ \*8
     - 4
     - MSB Int32
     - w001001.adf의 **t** 타일을 2바이트 Short 유형 단위로 측정해서 오프셋합니다.
   * - 
     - 104 + **t**\ \*8
     - 4
     - MSB Int32
     - **t** 타일의 2바이트 Short 유형 단위 용량

--------------

sta.adf - 래스터 통계
---------------------------

.. list-table:: Raster Statistics
   :header-rows: 1

   * - 필드명
     - 시작 바이트
     - 바이트 개수
     - 포맷
     - 설명
   * - SMin
     - 0
     - 8
     - MSB double
     - 이 그리드에 있는 래스터 셀의 최소값
   * - SMax
     - 8
     - 8
     - MSB double
     - 이 그리드에 있는 래스터 셀의 최대값
   * - SMean
     - 16
     - 8
     - MSB double
     - 이 그리드에 있는 래스터 셀들의 평균값
   * - SStdDev
     - 24
     - 8
     - MSB double
     - 이 그리드에 있는 래스터 셀들의 표준 편차

이 파일의 용량은 항상 32바이트입니다.

--------------

w001001.adf - Raster Data
-------------------------

다음은 w001001.adf 파일의 처음 320바이트를 바이너리 덤프한 것입니다.

::

          0: 0000270A FFFFFC14 00000000 00000000 ~~'~~~~~~~~~~~~~
         16: 00000000 00000000 00016DAE 00000000 ~~~~~~~~~~m~~~~~
         32: 00000000 00000000 00000000 00000000 ~~~~~~~~~~~~~~~~
         48: 00000000 00000000 00000000 00000000 ~~~~~~~~~~~~~~~~
         64: 00000000 00000000 00000000 00000000 ~~~~~~~~~~~~~~~~
         80: 00000000 00000000 00000000 00000000 ~~~~~~~~~~~~~~~~
         96: 00000000 02020800 00373D42 5C5A4D31 ~~~~~~~~~7=B\ZM1
        112: 200A0108 0E1D4F89 9C9A9392 8C7E6653  ~~~~~O~~~~~~~fS
        128: 5151596D 83919290 868A8B87 807A7A7B QQYm~~~~~~~~~zz{
        144: 7C7A766F 64481D00 0406305F 6B6C6A5B |zvodH~~~~0_klj[
        160: 5D53513C 2D2D2732 24293F54 40354C55 ]SQ<--'2$)?T@5LU
        176: 67686258 514E4943 5859534A 41394D70 ghbXQNICXYSJA9Mp
        192: 75665659 66625A63 737A848E 9090979F ufVYfbZcsz~~~~~~
        208: 9F908C8F 8F96998E 8778685B 53536274 ~~~~~~~~~xh[SSbt
        224: 747B838A 8A8C8F92 8D979B94 8C8D9294 t{~~~~~~~~~~~~~~
        240: 8D8D8D8D 8C8B8989 8B8E908F 8E8E9092 ~~~~~~~~~~~~~~~~
        256: 90929394 989C9891 92939698 9B9B9C9C ~~~~~~~~~~~~~~~~
        272: 8E8E8F8F 8E8E8F90 898E918F 8B8A8E93 ~~~~~~~~~~~~~~~~
        288: 8B8D9093 94918C86 838DA1BC B7CEC9B0 ~~~~~~~~~~~~~~~~
        304: D4B0BB96 A0929E99 9797999B 9D9C9C9B ~~~~~~~~~~~~~~~~

=========  =================  ==========================  ===================  =========================================================================================
필드명      시작 바이트         바이트 개수                  포맷                 설명
RMagic     0                  8                           Magic Number         언제나 16진법 00 00 27 0A FF FF \** \**로, 일반적으로 FC 14, FB F8 또는 FC 08로 끝납니다.
           8                  16                          zero fill
RFileSize  24                 4                           MSB Int32            전체 파일의 Short 유형 단위 용량(2를 곱하면 바이트 단위 파일 용량이 됩니다)
           28                 72                          zero fill
RTileSize  100, ...           2                           MSB Int16            Short 유형 단위로 측정한 타일 데이터 용량입니다. 색인에 있는 용량과 일치하며, 타일 크기 자체는 포함하지 않습니다. 다음 타일은 이 타일의 시작 부분으로부터 **2*n+2** 바이트 후에 시작합니다. 이때 이 필드의 값이 **n** 입니다.
RTileType  102, ...           1                           byte                 따라오는 데이터의 구조를 나타내는 타일 유형 코드입니다. (정수형 커버리지 전용)
RMinSize   103, ...           1                           byte                 타일의 최소값을 형성하기 위해 따라오는 바이트 개수입니다. (정수형 커버리지 전용)
RMin       104, ...           (RMinSize 바이트)            MSB Int (변수 크기)   이 타일의 최소값 픽셀들입니다. 이 타일에 있는 각 픽셀의 픽셀 값에 이 숫자를 더합니다. (정수형 커버리지 전용) RMinSize가 4 미만이더라도 여전히 부호 있는 양(quantity)입니다. 예를 들어 RMinSize가 2인 경우 이 값은 65536입니다 - byte0이 127을 초과하는 경우 byte0*256 - byte1이기 때문입니다.
RTileData  104+RMinSize, ...  RTileSize*2 - 3 - RMinSize  variable             이 타일의 데이터입니다. 정수형 커버리지의 경우 RTileType에 따라 포맷이 변합니다.
=========  =================  ==========================  ===================  =========================================================================================

RTileSize, RTileType, RMinSize, RMin, 그리고 RTileData 필드는 현재 데이터의 각 타일 파일에 나타납니다. 보통 서로 묶여 있지만, 반드시 그렇다고 정해진 것은 아닙니다. 타일 위치를 확인하려면 색인 파일(w001001x.adf)을 이용해야 합니다. 색인 파일에서 용량이 0인 타일은 해당 타일의 RTileSize가 2바이트(0 2개)로 나타날 것이라는 사실을 기억하십시오.

래스터 크기
~~~~~~~~~~~

그리드의 크기를 추정하는 것은 생각만큼 쉽지 않습니다. hdr.adf 파일은 특정한 래스터 공간을 시사하는 HTilesPerRow, HTilesPerColumn, HTileXSize 및 HTileYSize 필드를 담고 있지만, 이 공간은 사용자의 래스터 데이터를 담기 위해 필요한 공간보다 훨씬 더 크게 생성된 것으로 보입니다. 저자가 3x1 래스터를 생성했을 때, 각각 표준 256x4 픽셀 크기의 8x512 타일들을 산출했습니다.

dblbnd.adf 파일에 있는 (전체 래스터 공간의 좌상단에 고정된 것으로 추정되는) 지리참조 경계와 hdr.adf 파일의 HPixelSizeX 및 HPixelSizeY 필드를 기반으로 래스터의 사용자 부분을 계산해야 하는 것으로 보입니다.

**픽셀 개수 = (D_URX - D_LRX) / HPixelSizeX**

**라인 개수 = (D_URY - D_LRY) / HPixelSizeY**

이 픽셀과 라인 개수를 바탕으로, 래스터의 좌상단에 있는 부분이 정말로 *관심 영역* 인지 확인할 수 있습니다. 이 영역 밖에 있는 모든 영역은 비어 있는 타일들로, 또는 NODATA 마커로 채워진 것으로 보입니다.

RTileType/RTileData
~~~~~~~~~~~~~~~~~~~

각 타일은 데이터의 HBlockXSize \* HBlockYSize 개 픽셀을 담고 있습니다. 부동소수점형 및 비압축 정수형 파일의 경우 데이터는 4바이트 MSB 순서 IEEE 부동소수점형 단어들인 픽셀 데이터 앞에 오는 (2바이트로 된) 타일 크기일 뿐입니다. 압축 정수형 타일의 경우 타일 구조의 상세 정보를 확인하기 위해 RTileType을 해석해야 합니다.

RTileType = 0x00 (상수 블록(constant block))
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

모든 블록이 RMin 값을 취합니다. 데이터는 무시합니다. 블록 안에 (4바이트까지의) 의미 없는 데이터 한 조각이 존재하는 경우가 있는 것으로 보입니다.

RTileType = 0x01 (원본(raw) 1비트 데이터)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

RMin 필드 뒤에 오는, 타일 전체에 해당하는 픽셀 당 1비트를 가진 데이터 픽셀 값입니다.

RTileType = 0x04 (원본(raw) 4비트 데이터)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

RMin 필드 뒤에 오는, 타일 전체에 해당하는 픽셀 당 4비트를 가진 데이터 픽셀 값입니다. 바이트의 상위(high order) 4비트가 하위(low order) 4비트 앞에 옵니다.

RTileType = 0x08 (원본(raw) 바이트 데이터)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

RMin 필드 뒤에 오는, 타일 전체에 해당하는 픽셀 당 1바이트를 가진 데이터 픽셀 값입니다.

RTileType = 0x10 (원본(raw) 16비트 데이터)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

RMin 필드 뒤에 오는, 타일 전체에 해당하는 픽셀 당 16비트(MSB)를 가진 데이터 픽셀 값입니다.

RTileType = 0x20 (원본(raw) 32비트 데이터)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

RMin 필드 뒤에 오는, 타일 전체에 해당하는 픽셀 당 32비트(MSB)를 가진 데이터 픽셀 값입니다.

RTileType = 0xCF (16비트 리터럴 런(literal run)/NODATA 런)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

데이터가 일련의 런(run)으로 조직되어 있습니다. 각 런은 다음과 같이 해석해야 하는 마커로 시작합니다:

-  **Marker < 128**: 픽셀 당 2개의 MSB 바이트를 가진 리터럴 데이터의 **Marker** 픽셀들이 마커 뒤에 옵니다.
-  **Marker > 127**: 이 마커는 산출 스트림에 *NODATA* 픽셀 가운데 **256-Marker** 픽셀들을 넣어야 한다는 사실을 나타냅니다. (다음 마커가 아닌) NODATA가 이 마커 뒤에 옵니다.

RTileType = 0xD7 (리터럴 런/NODATA 런)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

데이터가 일련의 런(run)으로 조직되어 있습니다. 각 런은 다음과 같이 해석해야 하는 마커로 시작합니다:

-  **Marker < 128**: 픽셀 당 1바이트를 가진 리터럴 데이터의 **Marker** 픽셀들이 마커 뒤에 옵니다.
-  **Marker > 127**: 이 마커는 산출 스트림에 *NODATA* 픽셀 가운데 **256-Marker** 픽셀들을 넣어야 한다는 사실을 나타냅니다. (다음 마커가 아닌) NODATA가 이 마커 뒤에 옵니다.

RTileType = 0xDF (RMin 런/NODATA 런)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

데이터가 일련의 런(run)으로 조직되어 있습니다. 각 런은 다음과 같이 해석해야 하는 마커로 시작합니다:

-  **Marker < 128**: 픽셀 당 1바이트를 가진 리터럴 데이터의 **Marker** 픽셀들이 마커 뒤에 옵니다.
-  **Marker > 127**: 이 마커는 산출 스트림에 *NODATA* 픽셀 가운데 **256-Marker** 픽셀들을 넣어야 한다는 사실을 나타냅니다. (다음 마커가 아닌) NODATA가 이 마커 뒤에 옵니다.

데이터 크기가 1이 아니라 0바이트라는 점을 제외하면, 0xD7과 유사합니다. 따라서 산출 스트림에 RMin 값만 삽입합니다.

RTileType = 0xE0 (런 렝스 부호화된 32비트)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

데이터가 일련의 런(run)으로 조직되어 있습니다. 각 런은 **count** 로 해석해야 하는 마커로 시작합니다. 이 개수 뒤에 오는 4바이트를 MSB Int32 **value** 로 해석해야 합니다. 산출 스트림에 **value** 값인 픽셀 **count** 개를 삽입해야 한다는 사실을 나타냅니다.

RTileType = 0xF0 (런 렝스 부호화된 16비트)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

데이터가 일련의 런(run)으로 조직되어 있습니다. 각 런은 **count** 로 해석해야 하는 마커로 시작합니다. 이 개수 뒤에 오는 2바이트를 MSB Int16 **value** 로 해석해야 합니다. 산출 스트림에 **value** 값인 픽셀 **count** 개를 삽입해야 한다는 사실을 나타냅니다.

RTileType = 0xFC/0xF8 (런 렝스 부호화된 8비트)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

데이터가 일련의 런(run)으로 조직되어 있습니다. 각 런은 **count** 로 해석해야 하는 마커로 시작합니다. 이 뒤에 오는 1바이트가 **value** 입니다. 산출 스트림에 **value** 값인 픽셀 **count** 개를 삽입해야 한다는 사실을 나타냅니다.

이 해석은 0xFC 및 0xF8에서 동일합니다. 0xFC가 0xF8의 동적 범위(4 또는 8비트)보다 더 좁은 동적 범위(2비트)를 가진 것으로 보입니다.

RTileType = 0xFF (RMin CCITT 런 렝스 부호화된 1비트)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

이 파일의 데이터 스트림은 압축된 (G1 팩스 모뎀 표준인) CCITT RLE(Run-Length Encoding)입니다. 이 포맷은 복잡하지만, 이 포맷을 읽을 수 있는 (libtiff에서 파생된) 샘플 프로그램과 함께 소스를 제공합니다. 압축 해제한 결과물이 1비트 데이터이기 때문에 RMin 값을 추가해야 합니다.

--------------

hdr.adf - 헤더
----------------

다음은 hdr.adf 파일의 처음 308바이트를 바이너리 덤프한 것입니다.

::

          0: 47524944 312E3200 00000000 FFFFFFFF GRID1.2~~~~~~~~~
         16: 00000001 00000000 0000164E 3F800000 ~~~~~~~~~~~N?~~~
         32: 00000F00 F6180000 90060000 3603D601 ~~~~~~~~~~~~6~~~
         48: 6403E301 01000000 7620F808 43012B03 d~~~~~~~v ~~C~+~
         64: D6019903 E3012B03 D6019903 E301F7BF ~~~~~~+~~~~~~~~~
         80: 00007406 6E1FC2A4 7A370D00 0B004200 ~~t~n~~~z7~~~~B~
         96: 4E1654A4 00000000 00000000 00000000 N~T~~~~~~~~~~~~~
        112: 34A5A89D FF0414A5 A70F0002 00000000 4~~~~~~~~~~~~~~~
        128: 00000000 3C0B5F06 A8C05F06 08005AC0 ~~~~<~_~~~_~~~Z~
        144: 0A00E101 36035AC0 72085F06 FAA42F3C ~~~~6~Z~r~_~~~/<
        160: 0A001667 02000E00 A80B0200 08370200 ~~~g~~~~~~~~~7~~
        176: 0CA00200 9C0B0200 04370200 36A0E436 ~~~~~~~~~7~~6~~6
        192: 84000000 36A00200 5F063EA5 0883FF04 ~~~~6~~~_~>~~~~~
        208: 00008400 00000010 BD810200 5F010000 ~~~~~~~~~~~~_~~~
        224: 670E0000 5F01560E 4C4F0001 84008CA5 g~~~_~V~LO~~~~~~
        240: 28008F01 1000E00A 6628F7BF 4076FF04 (~~~~~~~f(~~@v~~
        256: 3FF00000 00000000 3FF00000 00000000 ?~~~~~~~?~~~~~~~
        272: C08FFC00 00000000 C0A1BF00 00000000 ~~~~~~~~~~~~~~~~
        288: 00000008 00000200 00000100 00000001 ~~~~~~~~~~~~~~~~
        304: 00000004                            ~~~~

================  ===========  ===========  ============  =========================================================================================
필드명             시작 바이트   바이트 개수   포맷          설명
HMagic            0            8            Char          매직 넘버(Magic Number) - 항상 "GRID1.2\0"
                  8            8                          여러 데이터, 목적 파악 안 됨
HCellType         16           4            MSB Int32     1 = 정수형 커버리지, 2 = 부동소수점형 커버리지
CompFlag          20           4            MSB Int32     0 = 압축, 1 = 비압축
                  24           232                        여러 데이터, 목적 파악 안 됨
HPixelSizeX       256          8            MSB Double    지리참조 좌표 단위의 픽셀 너비입니다. 지리참조되지 않은 래스터의 경우 일반적으로 1.0입니다.
HPixelSizeY       264          8            MSB Double    지리참조 좌표 단위의 픽셀 높이입니다. 지리참조되지 않은 래스터의 경우 일반적으로 1.0입니다.
XRef              272          8            MSB Double    dfLLX-(nBlocksPerRow*nBlockXSize*dfCellSizeX)/2.0
YRef              280          8            MSB Double    dfURY-(3*nBlocksPerColumn*nBlockYSize*dfCellSizeY)/2.0
HTilesPerRow      288          4            MSB Int32     타일 개수 단위의 파일 너비입니다. (너비가 2,000 미만인 파일의 경우 8인 경우가 많습니다.)
HTilesPerColumn   292          4            MSB Int32     타일 개수 단위의 파일 높이입니다. 색인 파일에 실제로 나타난 타일 개수보다 훨씬 많을 수도 있다는 사실을 기억하십시오.
HTileXSize        296          4            MSB Int32     픽셀 개수 단위의 타일 너비입니다. 일반적으로 256개입니다.
                  300          4            MSB Int32     알려지지 않음, 일반적으로 1입니다.
HTileYSize        304          4            MSB Int32     픽셀 개수 단위의 파일 높이입니다. 일반적으로 4개입니다.
================  ===========  ===========  ============  =========================================================================================

--------------

감사의 말
----------------

제가 이 포맷에 대한 연구를 할 수 있도록 연구비를 일부 지원해준 `Geosoft Inc. <http://www.geosoft.com/>`_ 에 감사드리고 싶습니다. 또한 다음 분들에게도 감사드립니다:

-  파일 포맷의 통계를 제공해주신 케네스 R. 맥베이(Kenneth R. McVay)
-  문제를 일으키는 수많은 데이터셋을 발굴하신 씽크스페이스(ThinkSpace) 사의 누레딘 파라(Noureddine Farah)
-  RTileType 0x01을 풀어주신 루시아누 폰세카(Luciano Fonseca)
-  추가적인 샘플 문제 파일들을 보내주신 글로벌 지오매틱스(Global Geomatics) 사의 마틴 매닝햄(Martin Manningham)
-  부동소수점형 타일은 RTileType 필드를 가지고 있지 않다는 사실을 알려주신 EDX 엔지니어링 사의 해리 앤더슨(Harry Anderson)
-  "Short 유형" RMin 값의 부호를 주의해야 하는 이유를 보여주는 샘플 파일들을 보내주신 이언 터튼(Ian Turton)
-  제가 결국 0xFF 타일을 추정해낼 때까지 열심히 쪼아주신 PCI 지오매틱스 사의 덩컨 차운디(Duncan Chaundy)
-  더 많은 문제 파일들을 보내주신 지오소프트(GeoSoft) 사의 스티븐 치즈맨(Stephen Cheeseman)
-  0x20 타일 유형을 보여주는 파일들을 보내주신 제프리 윌리엄스(Geoffrey Williams)
